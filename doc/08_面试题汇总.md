# SmartVoyage 项目面试题汇总

> 本文档整理了基于 MCP 和 A2A 协议的智能旅行助手项目相关的面试问题，帮助深入理解项目架构和核心技术。

---

## 一、项目整体架构

### Q1: 请简述 SmartVoyage 项目的整体架构？

**参考答案：**

SmartVoyage 是一个基于大模型的智能旅行助手系统，采用分层架构：

1. **前端层**：Streamlit 提供交互式聊天界面
2. **API 层**：FastAPI 提供 REST 接口，处理请求路由
3. **智能层**：
   - 意图识别器（IntentRecognizer）：识别用户意图
   - SQL 生成器（SQLGenerator）：将自然语言转为 SQL
4. **数据层**：MySQL 存储天气、火车票等数据
5. **爬虫层**：定时从和风天气 API 获取数据

```
用户 → Streamlit → FastAPI → 意图识别 → 数据库查询 → 返回结果
```

---

### Q2: MCP 和 A2A 协议分别是什么？它们的区别是什么？

**参考答案：**

| 协议 | 全称 | 作用 | 类比 |
|------|------|------|------|
| **MCP** | Model Context Protocol | LLM 调用外部工具/API | USB 接口标准 |
| **A2A** | Agent-to-Agent | Agent 之间相互通信协作 | 电话通讯协议 |

**MCP** 解决的是"LLM 如何使用工具"的问题，如查询数据库、调用 API。
**A2A** 解决的是"多个 Agent 如何协作"的问题，如天气 Agent 和票务 Agent 协同工作。

---

### Q3: 为什么选择 FastAPI 而不是 Flask？

**参考答案：**

1. **异步支持**：FastAPI 原生支持 async/await，适合 I/O 密集型操作（如数据库查询、API 调用）
2. **自动文档**：内置 Swagger UI，访问 `/docs` 即可查看 API 文档
3. **类型检查**：结合 Pydantic 进行请求/响应数据验证
4. **性能更高**：基于 Starlette 和 uvicorn，性能优于 Flask

---

## 二、意图识别与 NLU

### Q4: 意图识别是如何实现的？

**参考答案：**

意图识别通过 LLM + Prompt Engineering 实现：

```python
# 1. 构造提示词
PROMPT = """分析用户输入，识别意图。
支持的意图: weather, train_ticket, flight_ticket, concert
输出严格 JSON 格式..."""

# 2. 调用 LLM
response = llm.invoke(prompt.format(user_input=user_message))

# 3. 解析 JSON 结果
result = json.loads(response.content)
# → {"intent": "weather", "slots": {"city": "北京", "date": "今天"}}
```

**核心要点：**
- 使用低温度参数（temperature=0）确保输出稳定
- 提示词中明确要求输出 JSON 格式
- 通过正则表达式提取 JSON 块

---

### Q5: 意图识别和 SQL 生成有什么区别？

**参考答案：**

| 步骤 | 目的 | 输入 | 输出 |
|------|------|------|------|
| **意图识别** | 理解用户想做什么 | 自然语言 | 意图 + 槽位 |
| **SQL 生成** | 转换为数据库查询 | 意图 + 槽位 | SQL 语句 |

**流程示例：**
```
"北京明天天气" 
  → 意图识别 → {intent: "weather", slots: {city: "北京", date: "明天"}}
  → SQL生成 → SELECT * FROM weather_data WHERE city='北京' AND fx_date='2026-01-13'
```

---

### Q6: 如何处理用户输入信息不完整的情况？

**参考答案：**

通过 **追问机制** 实现：

```python
def needs_clarification(self, result):
    # 火车票必须有出发城市和目的城市
    if result.intent == "train_ticket":
        if not result.slots.get("from_city") or not result.slots.get("to_city"):
            return True
    return False
```

当检测到必要槽位缺失时，返回追问问题：
- "请问您想去哪个城市？"
- "请提供出发日期"

---

## 三、数据库设计

### Q7: 项目中使用了哪些数据库表？设计思路是什么？

**参考答案：**

| 表名 | 作用 | 唯一键 |
|------|------|--------|
| `weather_data` | 天气预报数据 | (city, fx_date) |
| `train_ticket` | 火车票信息 | (train_no, travel_date) |
| `flight_ticket` | 机票信息 | (flight_no, travel_date) |
| `concert_ticket` | 演唱会票 | (artist, city, start_time) |
| `city_code` | 城市代码映射 | city |

**设计思路：**
1. 使用复合唯一键避免重复数据
2. 采用 `ON DUPLICATE KEY UPDATE` 实现 UPSERT
3. 使用 `utf8mb4` 字符集支持中文

---

### Q8: 什么是数据库连接池？为什么要使用它？

**参考答案：**

**连接池** 是预先创建并维护的一组数据库连接。

**为什么使用：**
1. 避免频繁创建/销毁连接的开销
2. 限制最大连接数，保护数据库
3. 复用连接，提高性能

**项目实现：**
```python
# 使用 mysql.connector.pooling
pool = mysql.connector.pooling.MySQLConnectionPool(
    pool_name="smartvoyage",
    pool_size=5,  # 连接池大小
    **db_config
)

# 获取连接
conn = pool.get_connection()
```

---

### Q9: 如何防止 SQL 注入？

**参考答案：**

使用 **参数化查询**，而不是字符串拼接：

```python
# ❌ 危险：字符串拼接
sql = f"SELECT * FROM users WHERE name = '{user_input}'"

# ✅ 安全：参数化查询
sql = "SELECT * FROM users WHERE name = %s"
cursor.execute(sql, (user_input,))
```

参数化查询会自动转义特殊字符，防止恶意 SQL 注入。

---

## 四、LLM 与 LangChain

### Q10: LangChain 在项目中的作用是什么？

**参考答案：**

LangChain 是一个 LLM 应用开发框架，在项目中用于：

1. **封装 LLM 调用**：`ChatOpenAI` 类统一调用 OpenAI 兼容接口
2. **Prompt 模板**：`PromptTemplate` 管理提示词
3. **链式调用**：`chain = prompt | llm` 组合成处理流水线

```python
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate

llm = ChatOpenAI(model="qwen-plus", base_url="...", api_key="...")
prompt = PromptTemplate(template="...", input_variables=["user_input"])
chain = prompt | llm
result = chain.invoke({"user_input": "北京天气"})
```

---

### Q11: 什么是 Prompt Engineering？项目中如何应用？

**参考答案：**

Prompt Engineering 是设计和优化提示词以获得更好 LLM 输出的技术。

**项目中的应用：**

1. **明确输出格式**：要求输出 JSON，便于程序解析
2. **提供示例**：Few-shot learning，给出输入输出范例
3. **设置角色**：告诉 LLM 它是"意图识别专家"
4. **约束条件**：只输出 JSON，不要其他内容

```python
PROMPT = """你是一个意图识别助手。
### 支持的意图
1. weather: 天气查询
2. train_ticket: 火车票查询
### 输出格式
```json
{"intent": "xxx", "slots": {...}}
```
### 用户输入
{user_input}
"""
```

---

## 五、爬虫与定时任务

### Q12: 天气数据是如何获取和更新的？

**参考答案：**

1. **数据来源**：和风天气 API
2. **认证方式**：`X-QW-Api-Key` 请求头 或 `?key=` 参数
3. **定时更新**：使用 `schedule` 库每日执行

```python
import schedule

def update_weather():
    crawler = WeatherCrawler()
    crawler.update_hot_cities()  # 更新北京、上海、广州、深圳

# 每天凌晨 1 点执行
schedule.every().day.at("01:00").do(update_weather)

while True:
    schedule.run_pending()
    time.sleep(60)
```

---

### Q13: UPSERT 操作是什么？项目中如何实现？

**参考答案：**

UPSERT = UPDATE + INSERT，如果记录存在则更新，不存在则插入。

**MySQL 实现：**
```sql
INSERT INTO weather_data (city, fx_date, temp_max, temp_min)
VALUES ('北京', '2026-01-12', 5, -3)
ON DUPLICATE KEY UPDATE
    temp_max = VALUES(temp_max),
    temp_min = VALUES(temp_min);
```

**应用场景**：爬虫更新天气数据时，无需先查询再决定 INSERT 还是 UPDATE。

---

## 六、前端与用户交互

### Q14: 为什么选择 Streamlit 作为前端？

**参考答案：**

1. **快速开发**：纯 Python 编写，无需 HTML/CSS/JS
2. **内置组件**：聊天组件、侧边栏、按钮等开箱即用
3. **状态管理**：`st.session_state` 管理对话历史
4. **热重载**：修改代码自动刷新页面

**适用场景**：原型开发、数据应用、内部工具

---

### Q15: Streamlit 的 Session State 是什么？如何使用？

**参考答案：**

Session State 是 Streamlit 用于在页面刷新间保持数据的机制。

```python
# 初始化
if "messages" not in st.session_state:
    st.session_state.messages = []

# 使用
st.session_state.messages.append({"role": "user", "content": "你好"})

# 读取
for msg in st.session_state.messages:
    st.chat_message(msg["role"]).write(msg["content"])
```

**注意**：Session State 仅在当前会话有效，刷新浏览器会重置。

---

## 七、进阶问题

### Q16: 如果要将项目改造为分布式微服务架构，应该如何设计？

**参考答案：**

参考样例项目的架构：

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ MCP Weather │    │ MCP Ticket  │    │ MCP Order   │
│   :8002     │    │   :8001     │    │   :8003     │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       ↓                  ↓                  ↓
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ A2A Weather │    │ A2A Ticket  │    │ A2A Order   │
│   :5005     │    │   :5006     │    │   :5007     │
└─────────────┘    └─────────────┘    └─────────────┘
       ↑                  ↑                  ↑
       └──────────────────┼──────────────────┘
                          ↓
                   AgentNetwork (路由)
                          ↓
                      Streamlit
```

**改造步骤：**
1. 将每个功能拆分为独立的 MCP Server
2. 创建对应的 A2A Agent Server
3. 使用 AgentNetwork 管理 Agent 注册和路由
4. 客户端通过意图识别路由到对应 Agent

---

### Q17: 项目中有哪些可以优化的地方？

**参考答案：**

1. **缓存**：添加 Redis 缓存热门查询结果
2. **异步**：将同步 LLM 调用改为异步
3. **日志**：使用结构化日志（JSON格式）便于分析
4. **监控**：添加 Prometheus 指标监控 API 延迟
5. **测试**：补充单元测试和集成测试
6. **容器化**：使用 Docker Compose 管理多个服务

---

## 八、实际场景问题

### Q18: 如果用户问"帮我订一张明天北京到上海的火车票"，系统如何处理？

**参考答案：**

1. **意图识别**：识别为 `train_ticket` 或 `order` 意图
2. **槽位提取**：from_city=北京, to_city=上海, date=明天
3. **日期转换**：将"明天"转换为 "2026-01-13"
4. **数据库查询**：查询符合条件的车次
5. **返回结果**：格式化展示车次、时间、价格等

**当前限制**：本项目只支持查询，不支持真正的订票操作。

---

### Q19: 如何保证 LLM 输出的 JSON 格式正确？

**参考答案：**

1. **Prompt 约束**：明确要求只输出 JSON
2. **低温度**：`temperature=0` 减少随机性
3. **正则提取**：用正则表达式提取 JSON 块
4. **异常处理**：捕获 `json.JSONDecodeError`，返回默认值
5. **重试机制**：解析失败时重新请求

```python
import re
import json

# 提取 JSON 块
match = re.search(r'\{[\s\S]*\}', response_text)
if match:
    data = json.loads(match.group())
```

---

### Q20: 项目中如何处理并发请求？

**参考答案：**

1. **数据库连接池**：预创建连接，避免并发时创建过多连接
2. **FastAPI 异步**：使用 `async def` 处理 I/O 操作
3. **uvicorn workers**：可配置多个 worker 进程

```bash
# 生产环境启动（4 个 worker）
uvicorn app.main:app --workers 4 --host 0.0.0.0 --port 8000
```

---

## 总结

本项目涵盖了以下核心技术：
- 🤖 LLM 应用开发（LangChain、Prompt Engineering）
- 🔧 MCP/A2A 协议理解
- 🗄️ 数据库设计与连接池
- 🌐 REST API 开发（FastAPI）
- 🖥️ 前端开发（Streamlit）
- 🕷️ 数据爬取与定时任务

掌握这些知识点，即可应对大模型应用开发相关的面试问题。
